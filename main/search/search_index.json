{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Academy Extensions","text":"<p><code>academy-extensions</code> provides additional functionality that is adjacent to the core capabilities of <code>academy</code> and therefore not packaged with the rest of <code>academy</code> since it is not needed by all users.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install via github: <pre><code>git clone git@github.com:academy-agents/academy-extensions.git\ncd academy-extenstions\npython -m venv venv\n. ./venv/bin/activate\npip install -e .\n</code></pre></p> <p>Note, that currently <code>academy-extensions</code> relies on new features of <code>academy</code> not in version <code>0.3.0</code>. Till a new <code>academy</code> release is made, <code>academy-extensions</code> depends on the github version of <code>academy</code>. For now, this is impeding a PyPI release --- but we aim to release both a new version of <code>academy</code> and <code>academy-extensions</code> before 11/15/2025.</p> <p>For local development: <pre><code>$ tox --devenv venv -e py310\n$ pre-commit install\n</code></pre> or <pre><code>$ pip install -e .[dev]\n</code></pre></p>"},{"location":"#modules","title":"Modules","text":"<p>Academy-extensions currently provides the following modules:  - Academy MCP Plug-in</p>"},{"location":"api/","title":"academy_extensions","text":"<code>academy_extensions/__init__.py</code> <p>Academy extensions package.</p>"},{"location":"api/SUMMARY/","title":"SUMMARY","text":"<ul> <li>academy_extensions<ul> <li>academy_extensions.mcp</li> </ul> </li> </ul>"},{"location":"api/mcp/","title":"academy_extensions.mcp","text":"<code>academy_extensions/mcp.py</code> <p>MCP Server interface to Academy Exchange.</p>"},{"location":"api/mcp/#academy_extensions.mcp.AppContext","title":"AppContext  <code>dataclass</code>","text":"<pre><code>AppContext(\n    exchange_client: ExchangeClient[Any],\n    agents: set[AgentId[Any]] = set(),\n)\n</code></pre> <p>Application context with typed dependencies.</p>"},{"location":"api/mcp/#academy_extensions.mcp.format_name","title":"format_name","text":"<pre><code>format_name(agent: AgentId[Any], action: str) -&gt; str\n</code></pre> <p>Format an agent action into a tool name.</p> Source code in <code>academy_extensions/mcp.py</code> <pre><code>def format_name(agent: AgentId[Any], action: str) -&gt; str:\n    \"\"\"Format an agent action into a tool name.\"\"\"\n    return f'{agent.uid}_{action}'\n</code></pre>"},{"location":"api/mcp/#academy_extensions.mcp.wrap_agent","title":"wrap_agent  <code>async</code>","text":"<pre><code>wrap_agent(\n    server: FastMCP, agent: Handle[Any]\n) -&gt; dict[str, str]\n</code></pre> <p>Wrap tool from agent for use by server.</p> Source code in <code>academy_extensions/mcp.py</code> <pre><code>async def wrap_agent(server: FastMCP, agent: Handle[Any]) -&gt; dict[str, str]:\n    \"\"\"Wrap tool from agent for use by server.\"\"\"\n    logger.debug(f'Starting wrap agent for {agent.agent_id}')\n    agent_info = await agent.agent_describe()\n    logger.debug(f'Got description for {agent.agent_id}')\n    tools: dict[str, str] = {}\n    for action, description in agent_info.actions.items():\n        name = format_name(agent.agent_id, action)\n\n        async def invoke(\n            args: tuple[Any, ...],\n            kwargs: dict[str, Any],\n            name_: str = name,\n            action_: str = action,\n        ) -&gt; Any:\n            try:\n                return await agent.action(action_, *args, **kwargs)\n            except MailboxTerminatedError as e:\n                server.remove_tool(name_)\n                raise e\n\n        desc = (\n            f'This tool executes an action on agent {agent.agent_id}\\n'\n            f'Documentation: {description.doc}\\n'\n            f'Type Signature: {description.type_signature}\\n'\n            'Note: Arguments must be passed as `args`: a tuple of positional'\n            'arguments and `kwargs`: a dictionary of key-word arguments.'\n        )\n        server.add_tool(\n            invoke,\n            name=name,\n            title=action,\n            description=desc,\n        )\n        tools[name] = desc\n        logger.info(f'Added tool: {name}')\n\n    return tools\n</code></pre>"},{"location":"api/mcp/#academy_extensions.mcp.update_tools","title":"update_tools  <code>async</code>","text":"<pre><code>update_tools(\n    server: FastMCP,\n    existing: set[AgentId[Any]],\n    client: ExchangeClient[Any],\n    base_class: type[Agent] = Agent,\n    allow_subclasses: bool = True,\n) -&gt; dict[AgentId[Any], Task[Any]]\n</code></pre> <p>Update tools by discovering agents on the exchange.</p> Source code in <code>academy_extensions/mcp.py</code> <pre><code>async def update_tools(\n    server: FastMCP,\n    existing: set[AgentId[Any]],\n    client: ExchangeClient[Any],\n    base_class: type[Agent] = Agent,\n    allow_subclasses: bool = True,\n) -&gt; dict[AgentId[Any], asyncio.Task[Any]]:\n    \"\"\"Update tools by discovering agents on the exchange.\"\"\"\n    update_futures: dict[AgentId[Any], asyncio.Task[Any]] = {}\n    agent_ids = await client.discover(\n        base_class,\n        allow_subclasses=allow_subclasses,\n    )\n    new_agents = set(agent_ids) - existing\n    for agent_id in new_agents:\n        logger.info(f'Adding agent {agent_id}')\n        agent = Handle(agent_id)\n        # Create task in case agent is not online\n        update_futures[agent_id] = asyncio.create_task(\n            wrap_agent(server, agent),\n        )\n        existing.add(agent_id)\n\n    return update_futures\n</code></pre>"},{"location":"api/mcp/#academy_extensions.mcp.refresh_loop","title":"refresh_loop  <code>async</code>","text":"<pre><code>refresh_loop(\n    server: FastMCP,\n    context: AppContext,\n    interval_s: int = 300,\n) -&gt; None\n</code></pre> <p>Regularly update the discovered tools.</p> Source code in <code>academy_extensions/mcp.py</code> <pre><code>async def refresh_loop(\n    server: FastMCP,\n    context: AppContext,\n    interval_s: int = 300,\n) -&gt; None:\n    \"\"\"Regularly update the discovered tools.\"\"\"\n    tasks: list[asyncio.Task[Any]] = []\n    try:\n        while True:\n            updates = await update_tools(\n                server,\n                context.agents,\n                context.exchange_client,\n            )\n            tasks.extend(updates.values())\n            await asyncio.sleep(interval_s)\n    except asyncio.CancelledError as e:\n        for task in tasks:\n            task.cancel()\n\n        raise e\n</code></pre>"},{"location":"api/mcp/#academy_extensions.mcp.app_lifespan","title":"app_lifespan  <code>async</code>","text":"<pre><code>app_lifespan(server: FastMCP) -&gt; AsyncIterator[AppContext]\n</code></pre> <p>Initialize exchange client for lifespan of server.</p> Source code in <code>academy_extensions/mcp.py</code> <pre><code>@asynccontextmanager\nasync def app_lifespan(\n    server: FastMCP,\n) -&gt; AsyncIterator[AppContext]:\n    \"\"\"Initialize exchange client for lifespan of server.\"\"\"\n    if 'ACADEMY_MCP_EXCHANGE_ADDRESS' in os.environ:\n        url = os.environ['ACADEMY_MCP_EXCHANGE_ADDRESS']\n        auth = 'globus' if 'ACADEMY_MCP_EXCHANGE_AUTH' in os.environ else None\n        logger.info(f'Connection to exchange at {url}')\n        exchange_factory = HttpExchangeFactory(\n            url,\n            auth_method=auth,  # type: ignore\n        )\n    else:  # pragma: no cover\n        logger.info('Connection to exchange at dummy-address')\n        exchange_factory = HttpExchangeFactory(\n            'dummy-address',  #'https://exchange.academy-agents.org',\n            auth_method='globus',\n        )\n\n    async with await exchange_factory.create_user_client() as client:\n        logger.info('Connected to exchange')\n        context = AppContext(exchange_client=client)\n        refresh_task = asyncio.create_task(refresh_loop(server, context))\n        yield context\n        logger.info('Context exiting!')\n        refresh_task.cancel()\n</code></pre>"},{"location":"api/mcp/#academy_extensions.mcp.add_agent","title":"add_agent  <code>async</code>","text":"<pre><code>add_agent(\n    ctx: Context[ServerSession, AppContext], agent_uid: UUID\n) -&gt; dict[str, str]\n</code></pre> <p>Add agent to MCP server based on ID.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context[ServerSession, AppContext]</code>)           \u2013            <p>FastMCP context (provided)</p> </li> <li> <code>agent_uid</code>               (<code>UUID</code>)           \u2013            <p>uuid of the agent to add to MCP server.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, str]</code>           \u2013            <p>A dictionary of newely added actions and their docs.</p> </li> </ul> Source code in <code>academy_extensions/mcp.py</code> <pre><code>@mcp.tool()\nasync def add_agent(\n    ctx: Context[ServerSession, AppContext],\n    agent_uid: uuid.UUID,\n) -&gt; dict[str, str]:\n    \"\"\"Add agent to MCP server based on ID.\n\n    Args:\n        ctx: FastMCP context (provided)\n        agent_uid: uuid of the agent to add to MCP server.\n\n    Returns:\n        A dictionary of newely added actions and their docs.\n    \"\"\"\n    aid: AgentId[Any] = AgentId(uid=agent_uid)  # type: ignore[call-arg]\n    agent: Handle[Any] = Handle(aid)\n    tools = await wrap_agent(mcp, agent)\n    ctx.request_context.lifespan_context.agents.add(aid)\n    return tools\n</code></pre>"},{"location":"api/mcp/#academy_extensions.mcp.discover","title":"discover  <code>async</code>","text":"<pre><code>discover(\n    ctx: Context[ServerSession, AppContext],\n    agent: str,\n    module: str,\n    allow_subclasses: bool = True,\n) -&gt; tuple[UUID, ...]\n</code></pre> <p>Search for agents of type Agent on the exchange.</p> <p>To search for all agents, use agent_type=\"Agent\", module=\"academy.Agent\".</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context[ServerSession, AppContext]</code>)           \u2013            <p>FastMCP context (provided)</p> </li> <li> <code>agent</code>               (<code>str</code>)           \u2013            <p>The type of the agent to return.</p> </li> <li> <code>module</code>               (<code>str</code>)           \u2013            <p>The module where the agent was implemented.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the agent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[UUID, ...]</code>           \u2013            <p>Tuple of agent uids implementing the agent.</p> </li> </ul> Source code in <code>academy_extensions/mcp.py</code> <pre><code>@mcp.tool()\nasync def discover(\n    ctx: Context[ServerSession, AppContext],\n    agent: str,\n    module: str,\n    allow_subclasses: bool = True,\n) -&gt; tuple[uuid.UUID, ...]:\n    \"\"\"Search for agents of type Agent on the exchange.\n\n    To search for all agents, use agent_type=\"Agent\",\n    module=\"academy.Agent\".\n\n    Args:\n        ctx: FastMCP context (provided)\n        agent: The type of the agent to return.\n        module: The module where the agent was implemented.\n        allow_subclasses: Return agents implementing subclasses of the\n            agent.\n\n    Returns:\n        Tuple of agent uids implementing the agent.\n    \"\"\"\n    exchange = ctx.request_context.lifespan_context.exchange_client\n\n    fake_agent = type(agent, (Agent,), {'__module__': module})\n    assert (\n        f'{module}.{agent}' == f'{fake_agent.__module__}.{fake_agent.__name__}'\n    )\n    agent_ids = await exchange.discover(\n        fake_agent,\n        allow_subclasses=allow_subclasses,\n    )\n    return tuple(agent_id.uid for agent_id in agent_ids)\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#getting-started-for-local-development","title":"Getting Started for Local Development","text":"<p>We recommend using Tox to setup the development environment. This will create a new virtual environment with all of the required packages installed and academy-extensions installed in editable mode with the necessary extras options.</p> <pre><code>$ git clone https://github.com/academy-agents/academy-extensions\n$ cd academy-extensions\n$ tox --devenv venv -e py310\n$ . venv/bin/activate\n</code></pre> <p>Warning</p> <p>Running Tox in a Conda environment is possible but it may conflict with Tox's ability to find the correct Python versions. E.g., if your Conda environment is Python 3.9, running <code>$ tox -e p38</code> may still use Python 3.9.</p> <p>To install manually: <pre><code>$ git clone https://github.com/academy-agents/academy-extensions\n$ cd academy-extensions\n$ python -m venv venv\n$ . venv/bin/activate\n$ pip install -e .[dev,docs]\n</code></pre></p>"},{"location":"contributing/#continuous-integration","title":"Continuous Integration","text":"<p>Academy-extensions uses pre-commit and Tox for continuous integration (test, linting, etc.).</p>"},{"location":"contributing/#linting-and-type-checking-pre-commit","title":"Linting and Type Checking (pre-commit)","text":"<p>To use pre-commit, install the hook and then run against files.</p> <pre><code>$ pre-commit install\n$ pre-commit run --all-files\n</code></pre>"},{"location":"contributing/#tests-tox","title":"Tests (tox)","text":"<p>The entire CI workflow can be run with <code>$ tox</code>. This will test against multiple versions of Python and can be slow.</p> <p>Module-level unit-test are located in the <code>tests/</code> directory and its structure is intended to match that of <code>academy_extensions/</code>. E.g. the tests for <code>academy_extensions/x/y.py</code> are located in <code>tests/x/y_test.py</code>; however, additional test files can be added as needed. Tests should be narrowly focused and target a single aspect of the code's functionality, tests should not test internal implementation details of the code, and tests should not be dependent on the order in which they are run.</p> <p>Code that is useful for building tests but is not a test itself belongs in the <code>testing/</code> directory.</p> <pre><code># Run all tests in tests/\n$ tox -e py39\n# Run a specific test\n$ tox -e py39 -- tests/x/y_test.py::test_z\n</code></pre>"},{"location":"contributing/#docs","title":"Docs","text":"<p>If code changes require an update to the documentation (e.g., for function signature changes, new modules, etc.), the documentation can be built using MKDocs.</p> <pre><code># Manually\n$ pip install -e .[docs]\n$ mkdocs build --strict  # Build only to site/index.html\n$ mkdocs serve           # Serve locally\n\n# With tox (will only build, does not serve)\n$ tox -e docs\n</code></pre> <p>Docstrings are automatically generated, but it is recommended to check the generated docstrings to make sure details/links/etc. are correct.</p>"},{"location":"contributing/issues-pull-requests/","title":"Issues and Pull Requests","text":""},{"location":"contributing/issues-pull-requests/#issues","title":"Issues","text":"<p>Issue Tracker</p> <p>We use GitHub issues to report problems, request and track changes, and discuss future ideas. If you open an issue for a specific problem, please follow the template guides.</p>"},{"location":"contributing/issues-pull-requests/#pull-requests","title":"Pull Requests","text":"<p>We use the standard GitHub contribution cycle where all contributions are made via pull requests (including code owners!).</p> <ol> <li>Fork the repository and clone to your local machine.</li> <li>Create local changes.<ul> <li>Changes should conform to the style and testing guidelines, referenced   above.</li> <li>Preferred commit message format (source):<ul> <li>separate subject from body with a blank line,</li> <li>limit subject line to 50 characters,</li> <li>capitalize first word of subject line,</li> <li>do not end the subject line with a period,</li> <li>use the imperative mood for subject lines,</li> <li>include related issue numbers at end of subject line,</li> <li>wrap body at 72 characters, and</li> <li>use the body to explain what/why rather than how.   Example: <code>Fix concurrency bug in Store (#42)</code></li> </ul> </li> </ul> </li> <li>Push commits to your fork.<ul> <li>Please squash commits fixing mistakes to keep the git history clean.   For example, if commit \"b\" follows commit \"a\" and only fixes a small typo   from \"a\", please squash \"a\" and \"b\" into a single, correct commit.   This keeps the commit history readable and easier to search through when   debugging (e.g., git blame/bisect).</li> </ul> </li> <li>Open a pull request in this repository.<ul> <li>The pull request should include a description of the motivation for the   PR and included changes. A PR template is provided to guide this process.</li> </ul> </li> </ol>"},{"location":"contributing/releases/","title":"Releases","text":""},{"location":"contributing/releases/#release-timeline","title":"Release Timeline","text":"<p>Releases are created on an as-needed basis. Milestones are the Issue Tracker are used to track features to be included in upcoming releases.</p>"},{"location":"contributing/releases/#creating-releases","title":"Creating Releases","text":"<ol> <li>Choose the next version number, referred to as <code>{VERSION}</code> for the    rest of the instructions. Versioning follows semver    (<code>major.minor.patch</code>) with optional PEP-440    pre-release/post-release/dev-release segments. Major/minor/patch numbers    start at 0 and pre-release/post-release/dev-release segments start at 1.</li> <li>Update the version in <code>pyproject.toml</code> to <code>{VERSION}</code>.</li> <li>Commit and merge the version updates/changelogs into main.</li> <li>Tag the release commit and push (typically this is the commit updating the    version numbers).    <pre><code>$ git tag -s v{VERSION} -m \"academy-extensions v{VERSION}\"\n$ git push origin v{VERSION}\n</code></pre>    Note the version number is prepended by \"v\" for the tags so we can    distinguish release tags from non-release tags.</li> <li>Create a new release on GitHub using the tag. The title should be    <code>academy-extensions v{VERSION}</code>.</li> <li>Official release:<ol> <li>Use the \"Generate release notes\" option and set the previous tag as the previous official release tag. E.g., for <code>v0.4.1</code>, the previous release tag should be <code>v0.4.0</code> and NOT <code>v0.4.1a1</code>.</li> <li>Add an \"Upgrade Steps\" section at the top (see previous releases for examples).</li> <li>Review the generated notes and edit as needed. PRs are organized by tag, but some PRs will be missing tags and need to be moved from the \"Other Changes\" section to the correct section.</li> <li>Select \"Set as the latest release.\"</li> </ol> </li> <li>Unofficial release: (alpha/dev builds)<ol> <li>Do NOT generate release notes. The body can be along the lines of \"Development pre-prelease for <code>V{VERSION}</code>.\"</li> <li>Leave the previous tag as \"auto.\"</li> <li>Select \"Set as a pre-release.\"</li> </ol> </li> </ol>"},{"location":"contributing/style-guide/","title":"Style Guide","text":"<p>The Python code and docstring format mostly follows Google's Python Style Guide, but the pre-commit config is the authoritative source for code format compliance.</p> <p>Nits:</p> <ul> <li>Avoid imports in <code>__init__.py</code> (reduces the likelihood of circular imports).</li> <li>Prefer pure functions where possible.</li> <li>Define all class attributes inside <code>__init__</code> so all attributes are visible   in one place. Attributes that are defined later can be set as <code>None</code>   as a placeholder.</li> <li>Prefer f-strings (<code>f'name: {name}</code>) over string format   (<code>'name: {}'.format(name)</code>). Never use the <code>%</code> operator.</li> <li>Prefer typing.NamedTuple over collections.namedtuple.</li> <li>Use lower-case and no punctuation for log messages, but use upper-case and   punctuation for exception values.   <pre><code>logger.info(f'new connection opened to {address}')\nraise ValueError('Name must contain alphanumeric characters only.')\n</code></pre></li> <li>Document all exceptions that may be raised by a function in the docstring.</li> </ul>"},{"location":"guides/","title":"Guides","text":"<ul> <li>MCP</li> </ul>"},{"location":"guides/mcp/","title":"Running the Academy-MCP Plug-in","text":"<p>The Academy-MCP plug-in is an MCP server that connects to a (remote) Academy exchange instance.</p>"},{"location":"guides/mcp/#installation","title":"Installation","text":"<p><code>[bash] $ git clone git@github.com:academy-agents/academy-extensions.git $ cd academy-extenstions $ python -m venv venv $ . ./venv/bin/activate $ pip install -e . <pre><code>Refer to the installation of academy-extensions for more details\n\n\n## Running\nTo run the MCP server manually (i.e for testing or to connect to it as a remote MCP server), run:\n</code></pre> $ python -m academy_extensions.mcp <pre><code>To install it with claude desktop, using `uv`:\n</code></pre> $ uv run mcp install academy_extensions/mcp.py <pre><code>The exchange that the MCP server connects to defaults to the hosted exchange at https://exchange.academy-agents.org. To connect to a different exchange specify the url in an environment variable:\n</code></pre> $ export ACADEMY_MCP_EXCHANGE_ADDRESS=\"https://dummy-address.org/exchange\" $ export ACADEMY_MCP_EXCHANGE_AUTH=1 # If the exchange uses globus auth $ python -m academy_extensions.mcp <pre><code>or to configure the environment when installing:\n</code></pre> $ uv run mcp install academy_extensions/mcp.py -v ACADEMY_MCP_EXCHANGE_ADDRESS=...</code></p> <p>Note: Only the <code>HttpExchangeFactory</code> is currently supported with the Academy-MCP plug-in. We are working to be able to configure other exchange types.</p>"},{"location":"guides/mcp/#use","title":"Use","text":"<p>The MCP server discovers all agents that you have available to you and turns them in to MCP tools. The discovery script is run every 5 minutes to find new agents. You can manually discover agents using the <code>discover</code> tool, and add agents based on their <code>uid</code> using the <code>add_agent</code> tool.</p> <p>Currently we do not support agent management functionality (i.e. shutting down agents, terminating mailboxes, etc.).</p>"}]}